import type { FlashcardDefinition } from "@/types/flashcard";

export const pqcStandardsFlashcards: readonly FlashcardDefinition[] = [
  {
    id: "pqc-fc1",
    topicId: "pqc-standards",
    front: "PQCとは何か？量子暗号（QKD）との違いは？",
    back: "PQC（Post-Quantum Cryptography）: 古典コンピュータで実行でき、量子コンピュータでも破れない暗号。既存インフラに組み込み可能。\n\nQKD（Quantum Key Distribution）: 量子力学の原理を使う鍵配送。専用ハードウェア・光ファイバーが必要で距離制限あり。\n\n→ PQCの方が実用的でスケーラブル。",
    tags: ["PQC", "QKD", "overview"],
    relatedLessonId: "pqc-lesson-1",
  },
  {
    id: "pqc-fc2",
    topicId: "pqc-standards",
    front: "NIST PQC標準4つのFIPS番号と対応するアルゴリズムは？",
    back: "FIPS 203: ML-KEM（旧Kyber）— 鍵カプセル化\nFIPS 204: ML-DSA（旧Dilithium）— デジタル署名\nFIPS 205: SLH-DSA（旧SPHINCS+）— デジタル署名\nFIPS 206: FN-DSA（旧FALCON）— デジタル署名\n\n203/204/205は2024年8月公開。206は2025年公開予定。",
    tags: ["NIST", "FIPS", "standards"],
    relatedLessonId: "pqc-lesson-1",
  },
  {
    id: "pqc-fc3",
    topicId: "pqc-standards",
    front: "PQCの4つの数学的基盤は？",
    back: "1. 格子問題（Lattice）: ML-KEM, ML-DSA, FN-DSA → LWE, SVP問題\n2. ハッシュベース（Hash-based）: SLH-DSA → ハッシュ関数の安全性のみ\n3. 符号ベース（Code-based）: Classic McEliece → 線形符号の復号問題\n4. 多変数多項式（Multivariate）: 追加候補に残存\n\n格子ベースが主流。ハッシュベースがバックアップ。",
    tags: ["math", "lattice", "hash", "code"],
    relatedLessonId: "pqc-lesson-1",
  },
  {
    id: "pqc-fc4",
    topicId: "pqc-standards",
    front: "ML-KEM（旧Kyber）とは？パラメータセットは？",
    back: "FIPS 203標準の鍵カプセル化メカニズム。Module-LWE問題に基づく。ECDH/RSA鍵交換の量子耐性代替。\n\nML-KEM-512: Level 1, PK 800B, CT 768B\nML-KEM-768: Level 3, PK 1,184B, CT 1,088B（推奨）\nML-KEM-1024: Level 5, PK 1,568B, CT 1,568B\n\n共有秘密はすべて32バイト。",
    tags: ["ML-KEM", "Kyber", "KEM"],
    relatedLessonId: "pqc-lesson-2",
  },
  {
    id: "pqc-fc5",
    topicId: "pqc-standards",
    front: "KEMの3つの操作は？DH鍵交換との違いは？",
    back: "KEM: KeyGen → Encaps → Decaps\n- KeyGen: (pk, sk) を生成\n- Encaps(pk): (ct, ss) を生成。公開鍵で共有秘密をカプセル化\n- Decaps(sk, ct): ss を復元\n\nDH鍵交換: 双方が鍵ペアを生成し交換する対称的なプロトコル\nKEM: 一方が公開鍵を送り、他方がカプセル化する非対称的なプロトコル",
    tags: ["KEM", "key-exchange", "protocol"],
    relatedLessonId: "pqc-lesson-2",
  },
  {
    id: "pqc-fc6",
    topicId: "pqc-standards",
    front: "ML-DSA（旧Dilithium）とは？パラメータセットは？",
    back: "FIPS 204標準のデジタル署名。Module-LWE/SIS問題に基づく。NISTが最優先推奨。\n\nML-DSA-44: Level 2, PK 1,312B, Sig 2,420B\nML-DSA-65: Level 3, PK 1,952B, Sig 3,293B（推奨）\nML-DSA-87: Level 5, PK 2,592B, Sig 4,595B\n\n比較: ECDSA P-256 → PK 64B, Sig 64B（桁違いに大きい）",
    tags: ["ML-DSA", "Dilithium", "signature"],
    relatedLessonId: "pqc-lesson-3",
  },
  {
    id: "pqc-fc7",
    topicId: "pqc-standards",
    front: "ML-DSAのリジェクションサンプリングとは？",
    back: "署名生成時に z = y + c×s のノルムが閾値を超えた場合、署名を破棄して再生成するメカニズム。\n\n目的: 署名値から秘密鍵 s の情報がリークしないようにする。\n結果: 署名生成が非決定的（毎回異なる署名）。平均数回のリトライで成功。",
    tags: ["ML-DSA", "rejection-sampling", "security"],
    relatedLessonId: "pqc-lesson-3",
  },
  {
    id: "pqc-fc8",
    topicId: "pqc-standards",
    front: "SLH-DSA（旧SPHINCS+）の特徴と用途は？",
    back: "FIPS 205標準。ハッシュベースのステートレス署名。\n\n利点:\n- 安全性がハッシュ関数のみに依存（最も保守的）\n- 公開鍵が32Bと極小\n- 格子暗号のバックアップ\n\n欠点:\n- 署名が巨大（7-17KB）\n- 署名生成が遅い\n\n用途: ファームウェア署名、コードサイニング等、署名サイズより安全性の確実性を重視する場面。",
    tags: ["SLH-DSA", "SPHINCS+", "hash-based"],
    relatedLessonId: "pqc-lesson-4",
  },
  {
    id: "pqc-fc9",
    topicId: "pqc-standards",
    front: "FN-DSA（旧FALCON）の特徴と注意点は？",
    back: "FIPS 206標準。NTRU格子に基づく署名。\n\n利点:\n- PQC署名で最小の署名サイズ（666B）\n- 検証が高速\n\n注意点:\n- 浮動小数点演算が必要（ガウス分布サンプリング）\n- サイドチャネル攻撃のリスク\n- 実装が複雑\n\n用途: TLS証明書チェーン等、帯域幅がボトルネックの場面。",
    tags: ["FN-DSA", "FALCON", "NTRU"],
    relatedLessonId: "pqc-lesson-4",
  },
  {
    id: "pqc-fc10",
    topicId: "pqc-standards",
    front: "PQC署名の使い分け（コンサルティング推奨）",
    back: "一般用途: ML-DSA-65（バランス最良、NIST最優先推奨）\n帯域幅制約: FN-DSA-512（署名最小、実装注意）\n安全性最大: SLH-DSA（ハッシュのみに依存、格子の脆弱性に影響されない）\n高セキュリティ: ML-DSA-87（Level 5）\n\n「格子が破られたら？」→ SLH-DSAで対応可能と説明。",
    tags: ["comparison", "consulting", "recommendation"],
    relatedLessonId: "pqc-lesson-4",
  },
  {
    id: "pqc-fc11",
    topicId: "pqc-standards",
    front: "liboqs（Open Quantum Safe）とは？",
    back: "PQCアルゴリズムの実装を提供するOSSライブラリ。\n\n- C言語実装 + Python/Go/Java/Rust ラッパー\n- NIST標準アルゴリズムを網羅\n- oqs-provider: OpenSSL 3.x用プロバイダ\n- oqs-demos: TLS/SSH/VPN等のPQC対応デモ\n\nPQCの検証・ベンチマーク・PoC構築に必須のツール。",
    tags: ["liboqs", "OQS", "library"],
    relatedLessonId: "pqc-lesson-5",
  },
  {
    id: "pqc-fc12",
    topicId: "pqc-standards",
    front: "ハイブリッド鍵交換（X25519 + ML-KEM-768）とは？",
    back: "古典的鍵交換（X25519）とPQC（ML-KEM-768）を組み合わせた方式。\n\n手順:\n1. X25519でDH共有秘密を生成\n2. ML-KEM-768でPQC共有秘密を生成\n3. 両方をHKDFで結合して最終鍵を導出\n\n利点: どちらかが破られても安全（二重保護）。\nChromeが2024年からTLSでデフォルト有効化。",
    tags: ["hybrid", "X25519", "ML-KEM", "TLS"],
    relatedLessonId: "pqc-lesson-5",
  },
  {
    id: "pqc-fc13",
    topicId: "pqc-standards",
    front: "LWE（Learning With Errors）問題とは？",
    back: "ノイズ付き線形方程式 b = As + e から秘密ベクトル s を復元する問題。\n\n- A: 公開行列、s: 秘密ベクトル、e: 小さなノイズ\n- ノイズがなければ連立方程式で即座に解ける\n- ノイズがあると格子問題（SVP等）の困難性に帰着\n- 量子コンピュータでも効率的に解けないと考えられている\n\nML-KEM、ML-DSAの安全性の根拠。",
    tags: ["LWE", "lattice", "math"],
    relatedLessonId: "pqc-lesson-1",
  },
  {
    id: "pqc-fc14",
    topicId: "pqc-standards",
    front: "IND-CCA2安全性とは？ML-KEMとの関係は？",
    back: "IND-CCA2 = Indistinguishability under Adaptive Chosen Ciphertext Attack\n\n攻撃者が復号オラクルにアクセスでき、チャレンジ暗号文以外の任意の暗号文を復号できる状況でも、暗号文から平文の情報を得られない。\n\nML-KEMはFujisaki-Okamoto変換を適用してIND-CCA2安全性を実現。実用的な安全性の最高レベル。",
    tags: ["IND-CCA2", "security", "FO-transform"],
    relatedLessonId: "pqc-lesson-2",
  },
  {
    id: "pqc-fc15",
    topicId: "pqc-standards",
    front: "PQCの性能（ベンチマーク目安）は？",
    back: "ML-KEM-768: KeyGen 0.05ms, Encaps 0.07ms, Decaps 0.07ms\nML-DSA-65: KeyGen 0.15ms, Sign 0.50ms, Verify 0.15ms\nFN-DSA-512: KeyGen 5ms, Sign 0.8ms, Verify 0.1ms\nSLH-DSA-128f: KeyGen 0.3ms, Sign 15ms, Verify 0.5ms\n\nML-KEM/ML-DSAはECDH/ECDSAに匹敵する速度。SLH-DSAの署名は桁違いに遅い。鍵/署名サイズの増大が主な課題。",
    tags: ["performance", "benchmark"],
    relatedLessonId: "pqc-lesson-5",
  },
] as const satisfies readonly FlashcardDefinition[];
