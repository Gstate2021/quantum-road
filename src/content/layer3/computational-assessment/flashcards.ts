import type { FlashcardDefinition } from "@/types/flashcard";

export const computationalAssessmentFlashcards: readonly FlashcardDefinition[] = [
  {
    id: "comp-assess-fc1",
    topicId: "computational-assessment",
    front: "構造化ヒアリングの5つのカテゴリは？",
    back: "1. ビジネスコンテキスト（課題の業務プロセス、経済効果、タイムリミット）\n2. 問題の構造（変数、制約条件、目的関数）\n3. データ（種類・量・品質・更新頻度・機密性）\n4. 現行ソリューション（方法、性能、限界）\n5. 技術環境（IT基盤、チームスキル、予算）",
    tags: ["assessment", "hearing", "methodology"],
    relatedLessonId: "comp-assess-lesson1",
  },
  {
    id: "comp-assess-fc2",
    topicId: "computational-assessment",
    front: "「問題翻訳」の代表例を4つ挙げよ。",
    back: "・「配送ルートを効率化したい」→ TSP / VRP（巡回セールスマン/車両配送問題）\n・「シフトを自動で組みたい」→ ナーススケジューリング（制約充足問題）\n・「ポートフォリオを最適化したい」→ 二次計画問題（QUBO変換可能）\n・「設備故障を予測したい」→ 分類問題（古典ML向き）",
    tags: ["assessment", "translation", "problem-types"],
    relatedLessonId: "comp-assess-lesson1",
  },
  {
    id: "comp-assess-fc3",
    topicId: "computational-assessment",
    front: "数理モデル化の4ステップは？",
    back: "Step 1: 変数定義 — 決定すべき変数の型（バイナリ/整数/連続）と数を確定\nStep 2: 制約記述 — ハード制約・ソフト制約を数式で表現\nStep 3: 目的関数構築 — 最小化/最大化する指標を定義\nStep 4: 問題クラス分類 — LP/QP/MILP/QUBO/NLP/CSPに分類",
    tags: ["assessment", "modeling", "methodology"],
    relatedLessonId: "comp-assess-lesson2",
  },
  {
    id: "comp-assess-fc4",
    topicId: "computational-assessment",
    front: "ハード制約とソフト制約の違いは？",
    back: "ハード制約: 絶対に違反してはならない条件（例: トラックの最大積載量）\nソフト制約: 違反可能だがペナルティが発生する条件（例: 配送時間帯の希望）\n\nソフト制約はペナルティ項として目的関数に組み込み、重み付けで優先度を調整する。",
    tags: ["assessment", "constraints", "modeling"],
    relatedLessonId: "comp-assess-lesson2",
  },
  {
    id: "comp-assess-fc5",
    topicId: "computational-assessment",
    front: "主要な問題クラス（LP, QP, MILP, QUBO）を説明せよ。",
    back: "LP（線形計画）: 連続変数 + 線形目的関数 + 線形制約 → 多項式時間で解ける\nQP（二次計画）: 連続変数 + 二次目的関数 + 線形制約\nMILP（混合整数線形計画）: 整数変数含む + 線形 → NP困難\nQUBO（二次制約なしバイナリ最適化）: バイナリ変数 + 二次目的関数 + 制約なし（ペナルティで組込み） → 量子手法の入力形式",
    tags: ["assessment", "classification", "problem-types"],
    relatedLessonId: "comp-assess-lesson2",
  },
  {
    id: "comp-assess-fc6",
    topicId: "computational-assessment",
    front: "古典ファースト原則とは何か？",
    back: "まず古典計算手法（厳密ソルバー、メタヒューリスティクス）で十分に解けるかを検証し、不十分な場合にのみ量子インスパイアード・量子コンピューティングを検討する判断原則。\n\nLP/QPで変数100万未満 → 古典ソルバーで十分。コスト効率と信頼性の観点から推奨される。",
    tags: ["assessment", "decision", "principle"],
    relatedLessonId: "comp-assess-lesson3",
  },
  {
    id: "comp-assess-fc7",
    topicId: "computational-assessment",
    front: "3段階スクリーニングの判断フローを説明せよ。",
    back: "Stage 1: 古典厳密解は可能か？ → LP/QP小規模なら古典で十分\nStage 2: 古典ヒューリスティクスで目標精度を達成できるか？ → GA/SA等で十分なら古典\nStage 3: 量子/量子インスパイアードの適用判断 → QUBOに自然変換可能か？変数規模は？\n\n各ステージで「十分」なら、次のステージに進む必要はない。",
    tags: ["assessment", "screening", "decision"],
    relatedLessonId: "comp-assess-lesson3",
  },
  {
    id: "comp-assess-fc8",
    topicId: "computational-assessment",
    front: "古典vs量子の判断における5つの基準は？",
    back: "1. 問題規模と変数型: バイナリ変数の組合せ爆発が量子の主戦場\n2. 要求精度: 最適解必須か近似解で十分か\n3. 計算時間要件: リアルタイム(秒)/バッチ(時間)\n4. 問題の反復性: 繰り返し解く問題はチューニング投資を回収しやすい\n5. 経済合理性: 量子APIコスト vs 古典インフラコスト",
    tags: ["assessment", "criteria", "decision"],
    relatedLessonId: "comp-assess-lesson3",
  },
  {
    id: "comp-assess-fc9",
    topicId: "computational-assessment",
    front: "アセスメント報告書に含めるべき6項目は？",
    back: "1. 問題の定式化（数理モデル）\n2. 問題クラス分類結果\n3. 古典ベースラインの性能評価\n4. 量子的アプローチの適用可能性と期待される改善\n5. 推奨アプローチとロードマップ\n6. PoC計画（推奨アプローチの検証方法）",
    tags: ["assessment", "deliverable", "report"],
    relatedLessonId: "comp-assess-lesson3",
  },
  {
    id: "comp-assess-fc10",
    topicId: "computational-assessment",
    front: "QUBO変換のメリットと注意点は？",
    back: "メリット:\n・量子アニーリング、量子インスパイアード手法の入力形式として広く対応\n・制約をペナルティ項として目的関数に組み込める統一的な表現\n\n注意点:\n・すべての問題が自然に変換できるわけではない\n・連続変数のバイナリ化でオーバーヘッドが大きくなる場合がある\n・無理なQUBO変換はソリューション品質を下げる\n・ペナルティ重みのチューニングが解の質を大きく左右する",
    tags: ["assessment", "qubo", "modeling"],
    relatedLessonId: "comp-assess-lesson2",
  },
] as const satisfies readonly FlashcardDefinition[];
